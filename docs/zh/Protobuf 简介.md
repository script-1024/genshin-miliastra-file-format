# Protobuf 简介
千星奇域的资产文件主要以一个或多个 Protobuf 结构之形式存储，如果你对此不甚熟悉，建议参考[官方文档](https://protobuf.dev/programming-guides/encoding/)。当然，你也可以先看看这个文档，下面会用简单直白的方式带你快速熟悉！👌

若你发现本文档内容和官方版本有出入，请以官方为准。

## Varint - 可变长度整数类型
在存储文件或透过网络传输数据时，我们可能会希望尽可能地节省使用空间，避免保存太多重复/无用的数据。除了可以考虑对数据进行压缩以外，这里还给出了另一种能节省空间的办法：***可变长度整数***！

Varint 不使用固定的 32 位或 64 位整数，而是按需在每个字节的低 7 位存储数据；当剩余位数大于 7 时，通过设置最高位为 1 来表示后续还有字节。

### 转换规则
我们以十进制无符号整数 `360` 为例，来展示如何将整数转换成 Varint 形式：

1. 将 `360` 写作二进制形式：`1 0110 1000`
2. 从最低位开始，每 7 比特分成一组：`[第一组: 1101000, 第二组: 10]`
3. 将每组视为一个字节，用零填满成 8 位（对计算机而言，这一步是自动完成的）：`[0110 1000, 0000 0010]`
4. 从首字节开始，直至末尾前都需要把最高位填为 1：`[1110 1000, 0000 0010]`
5. 我们可以把它写作十六进制形式，方便人类阅读：`E8 02`

至此，我们完成了从无符号整数转换到 Varint 的所有流程 `360 --> E802`

### 代码实现
计算需要的缓冲区大小

- C#
  ```c#
  static int SizeOfVarintBuffer(ulong value) {
      if (value == 0) return 1; // 当 value 为零时也需要一字节的存储空间
      int bits = 64 - System.Numerics.BitOperations.LeadingZeroCount(value);
      return (bits + 6) / 7; // 等价于 ceil(bits / 7)
  }
  ```

- C/C++
  ```cpp
  // 使用 GCC 扩展方法
  int size_of_varint_buffer_gcc(uint64_t value) {
      if (!value) return 1;
      int bits = 64 - __builtin_clz(value);
      return (bits + 6) / 7;
  }
  // 自行实现
  int size_of_varint_buffer(uint64_t value) {
      int size = 1;
      while (value >= 0x80) { // 若仍有数据需要保存
        value >>= 7; // 每字节包含 7 个有效位
        size++;
      }
      return size;
  }
  ```

将无符号整数转为 Varint

- C#
  ```c#
  static byte[] ToVarint(ulong value) {
      int size = SizeOfVarintBuffer(value); // 见上方代码
      var result = new byte[size];
      for (int i = 0; i < size; i++) {
          byte data = (byte)(value & 0x7F); // 取得最低 7 位
          value >>= 7;
          if (value != 0) data |= 0x80; // 如果存在剩余数据，标记最高位
          result[i] = data;
      }
      return result;
  }
  ```

- C/C++
  ```cpp
  uint8_t* to_varint(uint64_t value) {
      int size = size_of_varint_buffer(value); // 见上方代码
      uint8_t* result = (uint8_t*) malloc(size);
      for (int i = 0; i < size; i++) {
          uint8_t data = (uint8_t)(value & 0x7F); // 取得最低 7 位
          value >>= 7;
          if (value != 0) data |= 0x80; // 如果存在剩余数据，标记最高位
          result[i] = data;
      }
      return result;
  }
  ```

将 Varint 解码成无符号整数

- C#
  ```c#
  static ulong DecodeVarint(byte[] raw) {
      ulong result = 0;
      // 若能保证 `raw` 是合法的 Varint 形式，两个循环退出条件只需要写一个；
      // 但假如它可能长度不足，或包含其他无关数据，就必须进行两次判断
      for (int i = 0; i < raw.Length; i++) {
          byte data = (byte)(raw[i] & 0x7F);
          result |= (ulong)(data) << (i * 7);
          if (raw[i] >> 7 == 0) break; // 若没有更多剩余数据，结束循环
      }
      return result;
  }
  ```

- C/C++
  ```cpp
  uint64_t decode_varint(uint8_t* raw, int size) {
      uint64_t result = 0;
      // 若能保证 `raw` 是合法的 Varint 形式，两个循环退出条件只需要写一个；
      // 但假如它可能长度不足，或包含其他无关数据，就必须进行两次判断
      for (int i = 0; i < size; i++) {
          uint8_t data = (byte)(raw[i] & 0x7F);
          reuslt |= (uint64_t)(data) << (i * 7);
          if (raw[i] >> 7 == 0) break; // 若没有更多剩余数据，结束循环
      }
  }
  ```

### 编码有符号整数
你可能已经注意到了，我们前面在讨论如何编码 Varint 时，一直都在强调使用 ***无符号整数***——这是因为现今大多数的计算机都使用一种被称作 ***补码*** 的形式保存负数，这能使得电路设计更加简单（无需关心一个整数是否为负，进行算术运算时利用自然溢出使得正负数相加为零）

使用补码表示负数时，我们仅需要将每一位都取反，再加上 1 即可。我们以 75 为例：
- 写作二进制：`75 --> 0100 1011`
- 按位取反：`1011 0100`
- 加 1：`1011 0101`

我们得到了 `-75 = 1011 0101`！

现在来验证一下，我们知道 `75 + (-75) = 0`，看看记作二进制后是否也符合此规则：
```
  0100 1011
+ 1011 0101
-----------
1 0000 0000
```

由于计算机使用定长位数保存整数，经过加法运算后超出存储范围的最高位 1 被舍弃，我们因此确定了 `75 + (-75) = 0` ✅

但在这种表示形式下，负数无论怎么位移其最高位总是为 1，转换算法将永远不会终止——这显然有问题！好在我们可以使用一种名叫 `ZigZag`（直译：曲折） 的技术先将有符号整数表示成无符号整数，再编码为 Varint：

| 转换前 | 转换后 |
|:-----:|:-----:|
|0|0|
|-1|1|
|1|2|
|-2|3|
|2|4|
|...|...|
|0x7FFFFFFF|0xFFFFFFFE|
|-0x80000000|0xFFFFFFFF|

由于正数和负数交替排列，因此得名。

- 编码方式：
  - `(n << 1) ^ (n >> 31)`（32位）
  - `(n << 1) ^ (n >> 63)`（64位）
- 解码方式
  - `(n >> 1) ^ -(n & 1)`

## Protobuf - 用于序列化数据结构的可扩展协议
Protobuf 是一种体积小、速度快，且无关语言的存储协议，以「消息」为单位，每个消息都定义一系列字段和其编号用来存放数据，它看起来像是这样：

```proto
message Person {
    int32  age  = 1; // 栏位1
    string name = 2; // 栏位2
}
```

1. 编码成二进制后，每段消息均以一个标签作为起始。

2. 某些标签可能缺失，可能乱序出现，可能重复出现（对象列表），因此解析器必须具备灵活读取标签的能力，不能依赖从文件读到的字节序列。
   > 注：尽管根据观察，原神应该都是按标签编号顺序写入文件的，但你不可以假定它们的顺序，因为第三方程序未必会遵守此规则！

3. 字段缺失时，理应返回该类型的默认值。
   > 注：原神有时会在某些值为零时直接省略不写入文件中，这点需要特别注意！
  
4. 标签自身的类型为 Varint，使用最低 3 位表示类型，其余有效位表示编号，格式为：`(id << 3) | type`。

5. 标签的编号必须是正整数。

6. 标签可用的种类如下，原神使用它们来表示特定类型：
   
    | ID | 名称 | 用途 |
    |:--:|:----|:-----|
    |0|VARINT|整数、枚举、布尔值|
    |1|FIXED64|双精度浮点数、定长64位整数（较少见）|
    |2|LENGTH|字符串、复合标签、列表、字典|
    |3|GROUP_START|（不使用）|
    |4|GROUP_END|（不使用）|
    |5|FIXED32|单精度浮点数、定长32位整数（较少见）|

  对于 LENGTH 类型，在标签之后还紧跟着一个额外字段用于指定内容长度，其类型为 Varint。

### 编码示例
假设某个字段编号为 `1`，表示一个复合标签，这个复合标签包含一个字符串 `"Hello, World!"`（栏位1）和一个布尔值 `true`（栏位2）：
  
1. 复合标签使用 LENGTH 类型存储：`(1 << 3) | 2 --> 0x0A`
2. 第一个子标签被计算为 `(1 <<　3) | 2 --> 0x0A`
3. 将字符串转为 UTF-8 编码的字节序列，不以 `\0` 结尾：`[0x48 0x65 0x6C 0x6C 0x6F 0x2C 0x20 0x57 0x6F 0x72 0x6C 0x64 0x21]`，长度为 `0x0D`
4. 第二个子标签被计算为 `(2 <<　3) | 0 --> 0x10`
5. 将 `true` 转换为 Varint：`0x01`
6. 计算根标签内容长度：`0x11`
7. 我们按照 `根标签 长度 子标签1 长度 内容 子标签2 数值` 的顺序写入文件中：`0A 11 0A 0D 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 10 01`
8. 完成！

假设某个字段编号为 `4`，存储了元件 GUID `1073741825`，并且游戏使用 `uint` 类型：

1. `uint` 类型属于整数，使用 VARINT 类型存储，此时标签值被计算为 `(4 << 3) | 0`，也就是 `0x20`
2. 将 `1073741825` 转换为 Varint 形式，得到 `[0x81, 0x80, 0x80, 0x80, 0x04]`
3. 依序将字节写入文件中：`20 81 80 80 80 04`
4. 完成！

事实上，如果你尝试导出一个界面控件组元件，并使用 VSCode 自带的十六进制编辑器打开它，你可能会在 `0x1D` 偏移处看到很像我们此处计算出来的数据，其实这就是游戏保存 GUID 的地方😉<br/>（虽然它可能会因为文件长度的不同而稍微改变位置，你不能在程序中硬编码这段偏移）
```
     00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
   + ———————————————————————————————————————————————
00 | 00 00 ?? ?? 00 00 00 01 00 00 03 26 00 00 00 03
10 | 00 00 ?? ?? 0A ?? ?? 0A 0A 10 01 18 08 20 81 80
20 | 80 80 04 (...后略)
```
> 注1：上述问号区域和文件大小相关，可参阅[概述](/docs/zh/概述.md)中关于文件头的介绍。
> 
> 注2：如果你发现导出的GUID和此处不同，这很正常。你可以试着手算一下，将其从 Varint 形式还原成整数，来验证自己是否掌握了本章节！
